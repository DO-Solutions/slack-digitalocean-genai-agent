from slack_bolt import Ack, Say, BoltContext
from logging import Logger
from ai.providers import get_provider_response
from slack_sdk import WebClient
from ..listener_utils.listener_constants import DEFAULT_LOADING_TEXT, SUMMARIZE_THREAD_PROMPT
from ..listener_utils.parse_conversation import parse_conversation
import re

"""
Callback for handling the 'sailor-summary' command. It acknowledges the command, parses the thread link,
retrieves the thread's conversation, and responds with a summary generated by the AI provider.
Users can also include a question about the thread after the link.
"""


def summary_callback(client: WebClient, ack: Ack, command, say: Say, logger: Logger, context: BoltContext):
    try:
        ack()
        user_id = context["user_id"]
        channel_id = context["channel_id"]
        command_text = command.get("text", "").strip()

        # If no text provided, inform the user
        if not command_text:
            client.chat_postEphemeral(
                channel=channel_id, 
                user=user_id, 
                text="Please provide a link to a Slack thread. Example: `/sailor-summary https://workspace.slack.com/archives/C12345678/p1234567890123456`"
            )
            return
        
        # Parse the thread link to extract channel ID and thread timestamp
        # Slack thread links format: https://workspace.slack.com/archives/C12345678/p1234567890123456
        thread_pattern = r'https://[^/]+/archives/([A-Z0-9]+)/p(\d+)'
        match = re.search(thread_pattern, command_text)
        
        if not match:
            client.chat_postEphemeral(
                channel=channel_id, 
                user=user_id, 
                text="Invalid thread link format. Please provide a valid Slack thread link."
            )
            return
        
        thread_channel_id = match.group(1)
        # Convert the timestamp format from p1234567890123456 to 1234567890.123456
        thread_ts = match.group(2)
        if len(thread_ts) > 10:
            thread_ts = f"{thread_ts[:10]}.{thread_ts[10:]}"
        
        # Extract user's question if provided after the thread link
        thread_link = match.group(0)
        user_question = command_text.replace(thread_link, "").strip()
        
        # Post a loading message to the user only
        client.chat_postEphemeral(
            channel=channel_id,
            user=user_id,
            text=DEFAULT_LOADING_TEXT
        )

        # Get thread messages
        try:
            thread_messages = client.conversations_replies(
                channel=thread_channel_id,
                ts=thread_ts
            )["messages"]
        except Exception as e:
            client.chat_postEphemeral(
                channel=channel_id,
                user=user_id,
                text=f"Error retrieving thread messages. Make sure Sailor has access to the channel and thread: {str(e)}"
            )
            return

        # Parse conversation
        conversation = parse_conversation(thread_messages)
        
        # Get response from AI provider
        if user_question:
            prompt = f"{SUMMARIZE_THREAD_PROMPT}\n\nAdditionally, please answer this question about the thread: {user_question}"
            title = "Thread Summary and Question Response"
        else:
            prompt = SUMMARIZE_THREAD_PROMPT
            title = "Thread Summary"
            
        response = get_provider_response(user_id, prompt, conversation)
        
        # Process response to handle formatting issues
        # Split response into sections if it contains headers
        sections = []
        current_section = []
        
        for line in response.split('\n'):
            if line.startswith('##') or line.startswith('# '):
                # If we have content in current_section, add it to sections
                if current_section:
                    sections.append('\n'.join(current_section))
                    current_section = []
                # Strip markdown header symbols and make it bold
                header_text = line.lstrip('#').strip()
                current_section.append(f"*{header_text}*")
            else:
                current_section.append(line)
        
        # Add the last section
        if current_section:
            sections.append('\n'.join(current_section))
        
        # Create blocks for the message
        blocks = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": title
                }
            }
        ]
        
        # Add each section as a separate block
        for section in sections:
            blocks.append({
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": section
                }
            })

        # Send response as ephemeral message (only visible to the user)
        client.chat_postEphemeral(
            channel=channel_id,
            user=user_id,
            text=title,
            blocks=blocks,
        )
    except Exception as e:
        logger.error(e)
        client.chat_postEphemeral(channel=channel_id, user=user_id, text=f"Received an error from Bolty:\n{e}") 